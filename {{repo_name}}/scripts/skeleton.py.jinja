from __future__ import annotations

import argparse
import urllib.request
import json
import pprint
import sys
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable
    from typing import Literal
    from typing_extensions import TypeAlias


_OPERATION_HOOKS: dict[str, Callable[..., None]] = defaultdict(list)
Operation: TypeAlias = Literal["copy", "update"]


def after(operation: Operation) -> Callable[[Callable[..., None]], Callable[..., None]]:
    """Run the script."""
    def decorator(func: Callable[..., None]) -> Callable[..., None]:
        _OPERATION_HOOKS[operation] = func
        return func
    return decorator


@after("copy")
def create_license_file() -> None:
    # Update the variable through copier, not manually.
    license_name = "{{license_name}}"
    if license_name == "None":
        return

    license_text: str | None
    try:
        license_response = json.loads(
            urllib.request.urlopen(
                f"https://api.github.com/licenses/{license_name}"
            ).read(),
        )
    except urllib.error.HTTPError as exc:
        print(f"Error finding license {license_name}: {exc}", file=sys.stderr)
        license_text = None
    else:
        try:
            license_text = license_response["body"]
        except KeyError:
            print(f"Incorrect license output for {license_name}", file=sys.stderr)
            pprint.pprint(license_response, stream=sys.stderr)
            license_text = None

    if license_text:
        final_license_text = license_text.replace(
            "[year]",
            f"{datetime.now().year}â€“present",
        ).replace(
            "[fullname]",
            "{{author_full_name}} ({{github_username}})",
        )
        Path("LICENSE").write_text(final_license_text)


def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description="Project update hook.")
    parser.add_argument(
        "operation",
        type=str,
        nargs=1,
    )
    args = parser.parse_args(argv)
    operation = args.operation.pop()

    for hook in _OPERATION_HOOKS[operation]:
        hook()


if __name__ == "__main__":
    main()